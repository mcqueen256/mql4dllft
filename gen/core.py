from decoder import decode_functions, decode_properties
from jinja2 import Template
from FunctionTranslator import FunctionTranslator

import os
import logging

context = {}
settings = {
    'DUP_LEVEL': 5
}


def init(debug=False, verbos=False):
    global context, settings

    # Configure logging
    level = logging.NOTSET
    if verbos:
        level = logging.INFO
    if debug:
        level = logging.DEBUG
    logging.basicConfig(filename='../output/generator.log', level=level)
    logging.debug('   --=== Initialised the core! ===--   ')


# Decorators ##################################################################


def require_properties(func, *args, **kwargs):
    """Decorator for ensuring that the MQL properties are in the context."""

    def inner(*args, **kwargs):
        global context
        if 'properties' not in context.keys():
            context['properties'] = decode_properties()
        return func(*args, **kwargs)

    return inner


def require_functions(func, *args, **kwargs):
    """Decorator for ensuring that the MQL functions is in the context."""

    def inner(*args, **kwargs):
        global context
        if 'functions' not in context.keys():
            context['functions'] = decode_functions()
        return func(*args, **kwargs)

    return inner


def require_context(func, *args, **kwargs):
    """Decorator that gives a function the context as the first parameter."""

    def f(*args, **kwargs):
        global context
        return func(context, *args, **kwargs)

    return f


def require_function_translator(func, *args, **kwargs):
    """Decorator that gives a function translation object in the context."""

    @require_functions
    def inner(*args, **kwargs):
        global context
        if 'function_translator' not in context.keys():
            context['function_translator'] = FunctionTranslator(context)
        return func(*args, **kwargs)

    return inner


# Utility #####################################################################


@require_properties
@require_context
def get_property_c_lines(ctx, category):
    # Prepare properties lines
    property_lines = []
    for key, val in ctx['properties'][category].items():
        prop = '_'.join(key.split())
        if val is not None:
            prop += ' ' + str(val)
        line = '#property {}'.format(prop)
        property_lines.append(line)
    return property_lines


def get_common_property_c_lines():
    return get_property_c_lines('common')


def get_indicator_property_c_lines():
    return get_property_c_lines('indicator')


def get_expert_property_c_lines():
    return get_property_c_lines('expert')


@require_context
def get_buffer_property_c_lines(ctx):
    property_buffers = []
    for i, buffer in enumerate(ctx['properties']['buffers']):
        lines = []
        for key in buffer.keys():
            val = buffer[key]
            # special conditions
            if val is None: continue
            if key.endswith('color'):
                pass  # do nothing to val
            elif key.endswith('style'):
                val = 'STYLE_' + val.upper()
            elif type(val) is str:
                val = '"{}"'.format(val)
            # generate the line
            prop = '_'.join(key.split())
            line = "#property indicator_{}{} {}".format(prop, i + 1, val)
            lines.append(line)
        property_buffers.append(lines)
    return property_buffers


@require_properties
@require_context
def get_input_c_lines(ctx):
    return ctx['properties']['inputs']


@require_context
def get_buffer_register_lines(ctx):
    lines = []
    for i, buffer in enumerate(ctx['properties']['buffers']):
        name = buffer['name'] if 'name' in buffer.keys() else 'AutoGeneratedBuffer' + str(i)
        name = ''.join([x.capitalize() for x in name.split()])
        line = "SetIndexBuffer({}, {}Buffer);".format(i, name)
        lines.append(line)
    return lines


@require_context
def get_buffer_name_lines(ctx):
    lines = []
    for i, buffer in enumerate(ctx['properties']['buffers']):
        name = buffer['name'] if 'name' in buffer.keys() else 'AutoGeneratedBuffer' + str(i)
        name = ''.join([x.capitalize() for x in name.split()])
        line = "double {}Buffer[];".format(name)
        lines.append(line)
    return lines


# Actionable code wrapped in classes #############################################################


class Expert:
    """Class to be passed to the template"""

    @require_properties
    @require_function_translator
    def __init__(self):
        global context
        self.property_buffers = get_buffer_property_c_lines()
        self.buffer_register_lines = get_buffer_register_lines()
        self.property_lines = get_common_property_c_lines()
        self.name = context['properties']['name']
        self.input_lines = get_input_c_lines()
        self.ft = context['function_translator']


class Indicator:
    """Class to be passed to the template"""

    def __init__(self):
        self.property_lines = get_common_property_c_lines()
        self.property_buffers = get_buffer_property_c_lines()
        self.buffer_register_lines = get_buffer_register_lines()
        self.buffer_name_lines = get_buffer_name_lines()
        self.input_lines = get_input_c_lines()


class Common:
    pass


class Buffers:
    pass


@require_functions
@require_context
def get_functions_dict_by_namespace(ctx):
    """Returns a dictionary that maps the namespace a group of function belong to, to the list of those functions.
    """
    functions = ctx["functions"]
    func_dict_by_namespace = {}
    for function in functions:
        if function is not None:
            if function.getNamespace() not in func_dict_by_namespace.keys():
                func_dict_by_namespace[function.getNamespace()] = []
            func_dict_by_namespace[function.getNamespace()].append(function)
    return func_dict_by_namespace


@require_function_translator
@require_context
def get_function_translator(ctx):
    return ctx['function_translator']


def get_template_context():
    ctx = {
        'namespaces': get_functions_dict_by_namespace(),
        'expert': Expert(),
        'indicator': Indicator(),
        'common': Common(),
        'ft': get_function_translator(),
    }
    return ctx

def generate_all():
    # code = generate_mql_expert()
    # with open('../output/Expert.cpp', 'w') as fout:
    #     fout.write(code)
    #
    # code = generate_mql_functions()
    # with open('../output/mql4.cpp', 'w') as fout:
    #     fout.write(code)
    files = [file for file in os.listdir('templates') if not file.startswith('.')]
    for file_name in files:
        with open('templates/' + file_name, 'r') as fin:
            with open('../src/' + file_name, 'w') as fout:
                template = Template(fin.read())
                fout.write(template.render(**get_template_context()))
    return
